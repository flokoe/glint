# CLAUDE.md - Clairvoyance

**Last updated:** 2025-07-26

> **purpose** – This file is the onboarding manual for every AI assistant
> (Claude, Cursor, GPT, etc.) and every human who edits this repository.
> It encodes our coding standards, guard-rails, and workflow tricks so the
> *human 30 %* (architecture, tests, domain judgment) stays in human hands.[^1]

## 0. Project overview

Clairvoyance is a feature-rich web-based AI chat UI. It provides a
user-friendly interface for interacting with AI models through a web browser.
Key components:

- `frontend/`: SPA frontend writen in SvelteKit
- `backend/`: FastAPI Python backend
- `cmd/`, `internal/`, `sql/` and `tempaltes/`: Old Golang related files

**Golden rule**: When unsure about implementation details or requirements,
ALWAYS consult the developer rather than making assumptions.

## 1. Non-negotiable golden rules

| #:  | AI *may* do | AI *must NOT* do |
| --- | ----------- | ---------------- |
| G-0 | Whenever unsure about something that's related to the project, ask the developer for clarification before making changes.    |  ❌ Write changes or use tools when you are not sure about something project specific, or if you don't have context for a particular feature/decision. |
| G-1 | Generate code **only inside** relevant source directories (e.g., `fontend/src/` for the frontend, `backend/` for the API or explicitly pointed files.    | ❌ Touch `tests/`, `SPEC.md`, or any `*_spec.py` / `*.ward` files (humans own tests & specs). |
| G-2 | Add/update **`AIDEV-NOTE:` anchor comments** near non-trivial edited code. | ❌ Delete or mangle existing `AIDEV-` comments.                                     |
| G-3 | Follow lint/style configs (`pyproject.toml`, `.ruff.toml`, `.pre-commit-config.yaml`). Use the project's configured linter, if available, instead of manually re-formatting code. | ❌ Re-format code to any other style.                                               |
| G-4 | For changes >300 LOC or >3 files, **ask for confirmation**.            | ❌ Refactor large modules without human guidance.                                     |
| G-5 | Stay within the current task context. Inform the dev if it'd be better to start afresh.                                  | ❌ Continue work from a prior prompt after "new task" – start a fresh session.      |

## 2. Build, test & utility commands

Use `just` recipes for consistency (they ensure correct environment variables
and configuration).

```bash
# Format, lint, type-check, test, codegen
poe format           # ruff format
poe lint             # ruff check
poe typecheck        # pytype --config pytype.toml (for agents-api) / pyright (for cli)
poe test             # ward test --exclude .venv (pytest for integrations-service)
poe test --search "pattern" # Run specific tests by Ward pattern
poe check            # format + lint + type + SQL validation
poe codegen          # generate API code (e.g., OpenAPI from TypeSpec)
```

For simple, quick Python script tests: `PYTHONPATH=$PWD python tests/test_file.py` (ensure correct CWD).

## 3. Coding standards

- **Python**: 3.12+, FastAPI, `async/await` preferred.
- **Formatting**: `ruff` enforces 96-char lines, double quotes, sorted imports. Standard `ruff` linter rules.
- **Typing**: Strict (Pydantic v2 models preferred); `from __future__ import annotations`.
- **Naming**: `snake_case` (functions/variables), `PascalCase` (classes), `SCREAMING_SNAKE` (constants).
- **Error Handling**: Typed exceptions; context managers for resources.
- **Documentation**: Google-style docstrings for public functions/classes.
- **Testing**: Separate test files matching source file patterns.

**Error handling patterns**:

- Use typed, hierarchical exceptions defined in `exceptions.py`
- Catch specific exceptions, not general `Exception`
- Use context managers for resources (database connections, file handles)
- For async code, use `try/finally` to ensure cleanup

Example:

```python
from agents_api.common.exceptions import ValidationError

async def process_data(data: dict) -> Result:
    try:
        # Process data
        return result
    except KeyError as e:
        raise ValidationError(f"Missing required field: {e}") from e
```

## 4. Project layout & Core Components

Initially this project was a Go based server application. We are now
transitioning to a FastAPI backend and a SvelteKit frontend.

### Old Golang based layout

#### Core Components

- **Web Framework**: Echo v4 for HTTP routing and middleware
- **Database**: SQLite with sqlc for type-safe SQL queries
- **Templates**: Go HTML templates with HTMX for dynamic content
- **Frontend**: Alpine.js for reactivity, HTMX for AJAX interactions

#### Directory Structure

- `cmd/clairvoyance/main.go` - Application entry point, server setup
- `internal/handler/` - HTTP handlers for chat and admin functionality
- `internal/database/` - Database models and queries (generated by sqlc)
- `internal/llm/` - LLM provider abstractions and implementations
- `sql/sqlite/` - SQL schema and queries
- `templates/` - HTML templates for server-side rendering
- `static/` - CSS, JavaScript, and other static assets

#### Database Schema

The application uses SQLite with the following main entities:

- `providers` - AI model providers (OpenAI-compatible endpoints)
- `llms` - Available language models
- `users` - User accounts
- `conversations` - Chat conversations
- `messages` - Individual messages in conversations

### Current layout

The project is currently transitioning from a Go-based server to a modern SvelteKit frontend with plans for a FastAPI backend.

#### Frontend Structure (SvelteKit)

| Directory/File                    | Description                                       |
| --------------------------------- | ------------------------------------------------- |
| `frontend/`                       | SvelteKit-based single-page application          |
| `frontend/src/`                   | Main source directory                             |
| `frontend/src/routes/`            | SvelteKit file-based routing                      |
| `frontend/src/lib/components/`    | Reusable Svelte components                        |
| `frontend/src/app.css`            | Global CSS styles                                 |
| `frontend/static/`                | Static assets (favicon, etc.)                    |
| `frontend/package.json`           | Dependencies and build scripts                    |

**Key Frontend Technologies**:
- **Framework**: SvelteKit with Svelte 5
- **Styling**: TailwindCSS 4.0 with forms and typography plugins
- **Build Tool**: Vite 7
- **Testing**: Vitest with Playwright for browser testing
- **Linting**: ESLint 9 with Prettier
- **TypeScript**: Full TypeScript support

**Frontend Components**:
- `BackgroundOrbs.svelte` - Animated background elements
- `ChatArea.svelte` - Main chat interface container
- `ChatView.svelte` - Primary chat view component
- `Message.svelte` - Individual message display
- `MessageInput.svelte` - Message composition interface
- `SearchDialog.svelte` - Search functionality overlay
- `Sidebar.svelte` - Navigation sidebar (expanded state)
- `SidebarCollapsed.svelte` - Navigation sidebar (collapsed state)
- `SidebarCollapsedBtn.svelte` - Toggle button for sidebar

#### Backend Structure (Legacy Go + Future Plans)

**Current Go Backend** (being phased out):
- `cmd/clairvoyance/main.go` - Application entry point
- `internal/handler/` - HTTP handlers for chat and admin
- `internal/database/` - SQLite database layer with sqlc
- `internal/llm/` - LLM provider abstractions
- `sql/sqlite/` - Database schema and queries
- `templates/` - Go HTML templates (legacy)
- `static/` - Static assets for Go templates (legacy)

**Planned Backend Architecture**:
- FastAPI-based backend service (to be implemented)
- Integration with existing SQLite database
- OpenAI-compatible LLM provider support

## 5. Anchor comments

Add specially formatted comments throughout the codebase, where appropriate, for
yourself as inline knowledge that can be easily `grep`ped for.

### Guidelines

- Use `AIDEV-NOTE:`, `AIDEV-TODO:`, or `AIDEV-QUESTION:` (all-caps prefix) for
  comments aimed at AI and developers.
- Keep them concise (≤ 120 chars).
- **Important:** Before scanning files, always first try to
  **locate existing anchors** `AIDEV-*` in relevant subdirectories.
- **Update relevant anchors** when modifying associated code.
- **Do not remove `AIDEV-NOTE`s** without explicit human instruction.
- Make sure to add relevant anchor comments, whenever a file or piece of code
  is:
  - too long, or
  - too complex, or
  - very important, or
  - confusing, or
  - could have a bug unrelated to the task you are currently working on.

Example:

```python
# AIDEV-NOTE: perf-hot-path; avoid extra allocations (see ADR-24)
async def render_feed(...):
    ...
```

## 6. Commit discipline

- **Granular commits**: One logical change per commit.
- **Tag AI-generated commits**: e.g., `feat: optimise feed query [AI]`.
- **Clear commit messages**: Explain the *why*; link to issues/ADRs if architectural.
- **Use `git worktree`** for parallel/long-running AI branches (e.g., `git worktree add ../wip-foo -b wip-foo`).
- **Review AI-generated code**: Never merge code you don't understand.

## 7. Directory-Specific AGENTS.md Files

- **Always check for `AGENTS.md` files in specific directories** before working
  on code within them. These files contain targeted context.
- If a directory's `AGENTS.md` is outdated or incorrect, **update it**.
- If you make significant changes to a directory's structure, patterns, or
  critical implementation details, **document these in its `AGENTS.md`**.
- If a directory lacks a `AGENTS.md` but contains complex logic or patterns
  worth documenting for AI/humans, **suggest creating one**.

## 8. Common pitfalls

- Large AI refactors in a single commit (makes `git bisect` difficult).
- Delegating test/spec writing entirely to AI (can lead to false confidence).

## 9. Domain-Specific Terminology

- **Agent**: An AI entity with specific instructions, tools, and capabilities, defined via API. Core model in `src/typespec/agents/models.tsp`.
- **Task**: A definition of a workflow composed of multiple steps that an agent can execute. Core model in `src/typespec/tasks/models.tsp`.
- **Tool**: A specific capability or integration an agent can use (e.g., web search, API call). Defined in `src/typespec/tools/`.
- **Session**: A container for a sequence of interactions (entries) with an agent, maintaining context. Core model in `src/typespec/sessions/models.tsp`.
- **Entry**: A single message or event within a session (e.g., user input, agent response). Core model in `src/typespec/entries/models.tsp`.
- **Execution**: The runtime instance and state of a task being performed by an agent. Core model in `src/typespec/executions/models.tsp`.
- **TypeSpec**: The language used to define API schemas. It is the source of truth for API models, which are then generated into Python Pydantic models in `autogen/` directories.
- **Ward**: The primary Python testing framework used for unit and integration tests in most components (e.g., `agents-api`, `cli`).
- **AIDEV-NOTE/TODO/QUESTION**: Specially formatted comments to provide inline context or tasks for AI assistants and developers.

## 10. Meta: Guidelines for updating AGENTS.md files

### Elements that would be helpful to add

1. **Decision flowchart**: A simple decision tree for "when to use X vs Y" for
   key architectural choices would guide my recommendations.
2. **Reference links**: Links to key files or implementation examples that
   demonstrate best practices.
3. **Domain-specific terminology**: A small glossary of project-specific terms
   would help me understand domain language correctly.
4. **Versioning conventions**: How the project handles versioning, both for
   APIs and internal components.

### Format preferences

1. **Consistent syntax highlighting**: Ensure all code blocks have proper
   language tags (`python`, `bash`, etc.).
2. **Hierarchical organization**: Consider using hierarchical numbering for
   subsections to make referencing easier.
3. **Tabular format for key facts**: The tables are very helpful - more
   structured data in tabular format would be valuable.
4. **Keywords or tags**: Adding semantic markers (like `#performance` or
   `#security`) to certain sections would help me quickly locate relevant
   guidance.

## 11. Files to NOT modify

These files control which files should be ignored by AI tools and indexing
systems:

- @.agentignore : Specifies files that should be ignored by the Cursor IDE,
  including:
  - Build and distribution directories
  - Environment and configuration files
  - Large data files (parquet, arrow, pickle, etc.)
  - Generated documentation
  - Package-manager files (lock files)
  - Logs and cache directories
  - IDE and editor files
  - Compiled binaries and media files

- @.agentindexignore : Controls which files are excluded from Cursor's indexing
  to improve performance, including:
  - All files in `.agentignore`
  - Files that may contain sensitive information
  - Large JSON data files
  - Generated TypeSpec outputs
  - Memory-store migration files
  - Docker templates and configuration files

**Never modify these ignore files** without explicit permission, as they're
carefully configured to optimize IDE performance while ensuring all relevant
code is properly indexed.

**When adding new files or directories**, check these ignore patterns to ensure
your files will be properly included in the IDE's indexing and AI assistance
features.

## 12. AI Assistant Workflow: Step-by-Step Methodology

When responding to user instructions, the AI assistant (Claude, Cursor, GPT,
etc.) should follow this process to ensure clarity, correctness, and
maintainability:

1. **Consult Relevant Guidance**: When the user gives an instruction, consult
   the relevant instructions from `AGENTS.md` files (both root and
   directory-specific) for the request.
2. **Clarify Ambiguities**: Based on what you could gather, see if there's any
   need for clarifications. If so, ask the user targeted questions before
   proceeding.
3. **Break Down & Plan**: Break down the task at hand and chalk out a rough
   plan for carrying it out, referencing project conventions and best practices.
4. **Trivial Tasks**: If the plan/request is trivial, go ahead and get started
   immediately.
5. **Non-Trivial Tasks**: Otherwise, present the plan to the user for review
   and iterate based on their feedback.
6. **Track Progress**: Use a to-do list (internally, or optionally in a
   `TODOS.md` file) to keep track of your progress on multi-step or complex
   tasks.
7. **If Stuck, Re-plan**: If you get stuck or blocked, return to step 3 to
   re-evaluate and adjust your plan.
8. **Update Documentation**: Once the user's request is fulfilled, update
   relevant anchor comments (`AIDEV-NOTE`, etc.) and `AGENTS.md` files in the
   files and directories you touched.
9. **User Review**: After completing the task, ask the user to review what
    you've done, and repeat the process as needed.
10. **Session Boundaries**: If the user's request isn't directly related to the
    current context and can be safely started in a fresh session, suggest
    starting from scratch to avoid context confusion.

[^1]: This principle emphasizes human oversight for critical aspects like architecture, testing, and domain-specific decisions, ensuring AI assists rather than fully dictates development.
